NOTES IN ADVANCE FOR AI DEV
I want to build this but- no free with credit card version, in fact skip all of the stripe stuff for now.  Just build the version where it acts like an inventory system and everything but the check out stuff.




Used Tire Inventory & Fitment SaaS – Technical & Product Specification
Overview
This document specifies a mobile-friendly, multi-tenant used tire inventory and fitment SaaS platform built with Next.js (App Router), Supabase (Postgres DB, Auth, Storage), and Vercel for hosting. Payment integration uses Stripe for both SaaS subscription billing and marketplace transactions (via Stripe Connect). The platform’s goal is to enable salvage yards and used-tire sellers (“yards”) to easily publish live tire inventories online, complete with vehicle fitment lookup and an optional e-commerce checkout for customers. Each yard operates its own branded public storefront (initially separate, not a unified marketplace), where customers can search tires by size or by vehicle year/make/model and see matching or compatible sizes. The system supports an optional checkout flow (online purchase) per yard, with robust stock management (quantity tracking, atomic inventory updates on sale) and Stripe Connect onboarding for payouts to the yards. Key Features & Requirements at a Glance:
Multi-Tenancy & Organization Management: Each yard corresponds to an organization tenant in the system. The data model isolates each yard’s data so that one yard cannot access another’s data, using an org_id (tenant identifier) on relevant tables. Supabase Row-Level Security (RLS) policies enforce that each authenticated user only accesses rows belonging to their own organization for secure multi-tenant operation. (One yard will have unlimited inventory “credits” – i.e. no hard limit on listings or usage for now.)
Mobile-First Public Storefront: The UI is designed mobile-first (responsive) for consumers searching tires on phones. Each yard has a public-facing site area showing their tire listings, branded with their name/logo. Initially, no aggregate marketplace view is provided (customers must visit a specific yard’s page to see that yard’s inventory). We may implement yard-specific subdomains (e.g. yardname.example.com) or path-based routing (e.g. example.com/yard/yardname) for tenant separation on the front-end. Using Next.js App Router with dynamic routes (and optionally middleware) allows implementing either approach – e.g. rewriting tenant.example.com to a route /[tenant] if we choose subdomains in the future. In this specification, a simple path-based approach will be described for initial implementation, with subdomains as a potential enhancement.
Tire Search (Size & Vehicle Fitment): Customers can search a yard’s inventory by entering a specific tire size (e.g. “205/55R16”) or by selecting their vehicle’s year, make, model (and possibly trim). For vehicle lookup, the system uses an external fitment data API to find the original tire sizes that fit the given vehicle (e.g. Wheel-Size.com’s API or similar). This data is cached in our database to avoid redundant API calls. When a customer searches by vehicle, the app retrieves the recommended tire size(s) for that vehicle (from cache or API) and then finds matching tires in the yard’s inventory. The search results should also include “similar size” alternatives: if no exact match is in stock, the platform suggests tires of compatible rim diameter and within a safe tolerance of overall diameter. Specifically, we match the wheel/rim size exactly and allow tire diameter variance within ~3% (the common maximum deviation for safe tire replacements). For example, if a customer needs 225/60R16 (overall diameter ~26.6"), tires that are within ±3% diameter (approximately 25.8" to 27.4") and same 16" rim could be suggested (such as 215/60R16 or 235/55R16, etc.). This improves the chance of finding usable alternatives while adhering to industry guidelines that replacement tires stay within ~3% of original diameter.
Inventory Listings & Batch Quantity: Each tire listing in the system represents a batch of identical tires with a quantity count. Instead of requiring separate entries for each individual tire, a yard can create one listing for a set of tires that share the same size/brand/model/tread, with a field for quantity (e.g. 8 tires available in that spec). All tire data fields (see Database Schema below) support this batch listing concept. When a purchase is made (via online checkout), the quantity is decremented accordingly, and if quantity hits zero the listing is marked out-of-stock or hidden. This batch approach simplifies management and ensures that identical tires are grouped.
Optional E-commerce Checkout: Yards can opt in to allow customers to purchase tires directly through the platform’s checkout. If enabled for a yard, customers can add available tires to a cart and go through an online checkout flow to pay. The checkout process will collect the buyer’s information (contact and shipping details if applicable) and payment. If a yard chooses not to enable checkout, their storefront will still display inventory and search, but instead of an “Add to Cart” button, it will show an alternate call-to-action (e.g. “Contact us to purchase” or similar). This way, yards that prefer in-person or phone sales can still use the platform purely for advertising inventory (they would likely be on a different pricing plan, described below).
Dual Pricing Model (SaaS Plans): The platform offers two business models for the yard organizations:
Listing-Only Plan ($99/month): Yard pays a flat $99 per month (after a 30-day free trial) to use the system, and in return the platform does not charge any transaction fees on sales – but notably, under this plan the yard is not using online checkout through the platform. This plan is intended for yards who want to list inventory (and possibly handle sales offline) or who prefer a flat subscription fee. In practice, this plan disables the online checkout feature on their storefront (no cart or payment – just inventory display).
Transaction-Fee Plan ($0/month + 2% fee): Yard pays no monthly fee, but if they do enable online sales, the platform takes a 2% commission on each transaction made through the online checkout. Stripe’s fees still apply as usual, but the platform’s 2% is an additional application fee. This 2% fee goes to the platform’s Stripe account via Stripe Connect. The yard can decide whether to absorb this 2% fee or pass it on to the customer. If the yard absorbs it, the customer pays the listed price and the platform deducts 2% from the payout. If the yard passes it on, the customer will be charged an extra 2% service fee at checkout (so the yard still receives the full price). The checkout implementation will accommodate both scenarios. For instance, if a tire is $100:
If absorbing fee, customer pays $100; Stripe will direct $98 to the yard’s account and $2 (2%) to the platform as an application fee.
If passing fee, customer pays $102 (an item of $100 + a service fee of $2); Stripe will transfer $100 to the yard and $2 to the platform. The use of Stripe Connect with an application_fee_amount on the PaymentIntent enables automatically splitting the fee to the platform. We simply adjust the checkout line items accordingly when a yard opts to pass fees on.
Both plans start with a 30-day free trial for new organizations. No credit card is required upfront for the trial. Before the trial ends, the yard must choose a plan and setup payment (if the $99 plan) or connect Stripe (if the fee plan) to continue using the service. The platform’s admin interface will remind/prompt them as the trial expiry approaches. Plan details and changes are managed in the admin settings (see Admin Dashboard section).
Stripe Integration (Subscriptions & Connect): Stripe is used in two ways: (1) Subscription billing for yards on the $99/month plan, and (2) Connect marketplace payments for handling customer checkouts and payouts to yards on the transaction-fee plan. We use Stripe Connect Express accounts for yards enabling checkout, which simplifies onboarding and allows the platform to manage payouts and fees. Yards will go through a Stripe Connect onboarding flow (providing bank account, tax info, etc.) so they can receive funds from sales. Our system will generate a Stripe Connect Account Link and redirect the user to Stripe’s hosted onboarding form; upon completion, Stripe returns to our platform (via a specified redirect URL) and we store the newly created stripe_account_id in the yard’s record. For subscription billing (the $99 plan), we will use Stripe’s standard subscription APIs – when a yard opts for that plan, they will enter a payment method and we create a Stripe Customer and Subscription for them (with a 30-day trial period configured). Stripe’s webhooks will inform us of subscription status changes (trial ending, payment failures, cancellations, etc.).
Checkout & Order Flow: For yards with online sales enabled, customers can select tires (specifying quantity up to what’s in stock) and proceed to checkout. We will implement checkout using Stripe Checkout Sessions for simplicity and security. When the buyer is ready to pay, our app will create a Checkout Session via Stripe’s API with line items for each tire (name, quantity, price) and the appropriate payment_intent_data including the Connect transfer_data[destination] (the yard’s Stripe Account ID) and application_fee_amount if applicable. The customer will be redirected to Stripe’s hosted checkout page to enter payment details securely. After payment, Stripe will redirect them back to a success page on our site (or a cancellation page if they abort). We will also listen for the checkout.session.completed webhook (and related events) on our backend to confirm the payment and create an Order record in our database. Each Order will contain details of the items, buyer info (which we collect either via Stripe Checkout’s built-in address collection or a preceding form), and payment status. If payment is successful, the order is marked as “Paid/Pending Fulfillment”. We atomically decrement the stock for each purchased tire item at this point. This will be done either by a single database call (ensuring quantity cannot go negative – e.g. SQL: UPDATE tires SET quantity = quantity - X WHERE id=... AND quantity >= X) or using a Supabase/Postgres function to handle the stock decrement within a transaction, to avoid race conditions if two customers buy simultaneously. Once stock hits zero, that tire listing will be flagged (so it no longer appears in search results).
Post-Checkout and Webhooks: After an order is placed, the yard will fulfill it outside the platform (e.g. arrange pickup or shipping with the customer). The platform will provide the yard with the buyer’s contact and address from the order details for this purpose. We will implement Stripe webhooks to handle other payment events: for example, if an order is refunded via Stripe, the webhook will mark the order as refunded in our DB (and optionally increment stock if the item is returned into inventory). If a charge is disputed (chargeback), we mark the order and alert the yard. Webhooks for subscription events (like end of trial, payment failed) will trigger emails or notifications to yard admins to update their plan or payment info. All webhook handling will be done in secure server-side endpoints (Next.js API routes or Edge Functions) with Stripe’s signature verification.
Admin Onboarding & Dashboard: Yards (organizations) sign up through a dedicated registration flow. Upon sign-up, the admin user can “brand” their yard by providing a yard name (which may be used in their storefront URL or page), contact info, logo upload, etc. The onboarding will then guide them to add their first tire listings – either manually via a form or by uploading a CSV file (if they have an existing inventory list). The CSV import tool will accept a defined schema (e.g. columns for size, brand, model, condition, price, quantity, etc.) and create multiple listings at once. After adding inventory, the admin can review their public storefront. The admin dashboard (which is the internal interface when a user from a yard is logged in) allows managing all aspects of their data:
Inventory Management: List of all tire listings with search/sort filters, and options to add new, edit or delete listings. For each listing they can set fields like size, brand, model, tire type, tread depth, condition (used/new), price, quantity, and upload photos. We will support multiple images per listing (so yards can show tread photos, sidewall, etc.), with one primary image cover. Images can be uploaded from phone or desktop and are immediately compressed for web optimization (details below).
Orders Management: (Only for yards using checkout) A list of orders placed by customers, with details like date, buyer name/contact, items and quantities, total paid, and status. Initially, statuses might be simple (“Paid”, “Refunded”, “Disputed”) and a field for whether the item has been marked “Shipped/Delivered” by the yard. The admin can view each order’s detail page and optionally update a fulfillment status or add notes/tracking info (this can be a deferred feature if needed).
Settings & Stripe Setup: Various configuration options for the yard. This includes general info (yard name, address, phone, website, logo), storefront preferences (e.g. enable/disable online checkout toggle, whether to pass on the 2% fee or absorb it), and Stripe Connect onboarding status. For yards on the transaction-fee plan, the Settings page will prominently show a “Connect with Stripe” button if they haven’t yet connected their Stripe account. This button triggers the Stripe Connect Express onboarding flow. If already connected, it might show status (e.g. “Stripe account connected: [Account ID]”) and perhaps a link to update their Stripe details. For yards on the subscription plan, the Settings page will show billing info – e.g. current plan, next payment date, on-trial status or not, and a way to update credit card or switch plans. We will also provide a way to cancel the subscription (which would downgrade them to a free/trial mode or require them to switch to the transaction plan).
User Management: (Possibly deferred for later) If we allow multiple user accounts per yard (e.g. invite coworkers), this page would list the current members of the organization and allow inviting new users by email with roles (Admin, Manager, etc.). Initially, to simplify, we might restrict to a single admin user per org in MVP, but the data model will allow expansion.
Audit Log: An admin view of recent actions taken within their organization (for accountability). Every critical action (adding/editing/deleting a listing, changing prices, fulfilling an order, changing settings) will generate an entry in an Audit Log table with timestamp, user, action description. This helps with internal tracking and also diagnosing any issues (for example, if a tire quantity became zero unexpectedly, the log might show if a user manually adjusted it or a sale decremented it). The audit log can be a simple list in the dashboard or even a raw table view.
Image Upload & Compression: To ensure performance on mobile and minimize storage, the platform will compress and resize images immediately on upload. When an admin (or staff) uploads tire photos, the client-side code will compress the image file before sending to the server. We can utilize the browser Canvas API or a library (e.g. browser-image-compression or compressorjs) to resize and compress images in the browser. For example, if a user selects a high-resolution photo, we can scale it down to a max dimension (e.g. 1200px) and reduce quality (e.g. 80% JPEG) before upload. This keeps file sizes small without noticeable quality loss, speeding up uploads and downloads. The benefits of client-side image compression include faster uploads, reduced bandwidth, and saving storage space. On the server side, we will also have a verification/compression step (possibly using an image processing library like Sharp in a serverless function or using Supabase Storage’s built-in image optimizer if available) as a fallback to ensure all images are web-friendly. Images will be stored in Supabase Storage buckets. We’ll organize a bucket (or folder path) per organization for easy management (e.g. a bucket tire-images with folders by org_id). Access to images can be public (since tire images aren’t sensitive) for simplicity – Supabase can provide public URLs, or we use Next.js Image component with a loader. If privacy is needed, we could issue signed URLs, but likely not necessary. Thumbnails for listing previews can be the same compressed image or we might generate separate thumbnail files if needed (could be deferred unless performance demands it).
Performance & Scalability: The app is built with Next.js which allows pre-rendering pages for speed and SEO. Tire listing pages and search results will be server-side rendered (SSR) or use static generation with revalidation where possible, to ensure fast first load and crawlability. Each tire listing might have its own page URL (for SEO, e.g. .../yard/slug/205-55R16-Brand-Model), and the site will be optimized with appropriate metadata (title, description including tire size and perhaps vehicle fitment keywords) to attract organic search traffic (many customers search Google for specific tire sizes). We will implement search result caching and potentially use Supabase’s full-text search or indexing for queries. The fitment API results are cached in our database so a popular vehicle lookup (e.g. “2015 Honda Civic”) doesn’t call the external API every time – this cache can be a table mapping vehicle queries to tire size results (updated periodically). For size-based search, queries will hit our Postgres DB directly which should be optimized with indexes on tire size fields. We anticipate the dataset per yard is manageable (most yards might have a few hundred to few thousand listings), and Supabase (Postgres) can handle this easily. If needed, we can add indices on size and possibly on diameter for quick similarity queries. The multi-tenant RLS approach does add a slight overhead to queries (because Postgres applies the row filter policy for each query), but this is negligible with proper indexing and given moderate data volumes. We will ensure the org_id is part of primary keys or indexed where used in queries to avoid full table scans under RLS conditions.
Security & Permissions: By leveraging Supabase Auth and RLS, our backend ensures that each logged-in user can only operate within their own organization’s data. All tables in the database will have RLS policies. For example, any query on the tires table will implicitly include WHERE org_id = current_user's org_id due to the policy, preventing leakage across tenants. We’ll implement a mechanism to include the user’s org_id in their JWT or use a join table lookup in the RLS policy. One common approach is adding a organizations claim to the JWT at login, or simply writing policies that check membership (e.g. EXISTS (SELECT 1 FROM memberships WHERE memberships.org_id = tires.org_id AND memberships.user_id = auth.uid())). For simplicity, we might restrict each user account to a single org in the first version (so auth.uid() can be directly associated with one org_id). Public (unauthenticated) users need to read tire listings for all yards’ storefronts. We will not expose a broad “read all” API to the public; instead, Next.js API routes (or the SSR process) will query the database for a specific yard’s inventory using a service role (bypassing RLS safely) or a pre-defined anon policy that only returns rows for a given org_id if provided. For instance, we can set up a stored procedure or use Supabase’s Row Level Security with a key: if a request has a specific org_id filter and an API key, allow reading those rows. In any case, we’ll ensure that one yard’s data isn’t inadvertently exposed under another’s page. Supabase’s policy system combined with careful query design will maintain tenant isolation while still allowing the intended public access to inventory on a per-yard basis.
Audit and Logging: All key actions and errors will be logged. On the client and server we’ll integrate basic logging (and possibly use a monitoring service or just Vercel logs). The Audit Log (mentioned in admin features) records user actions for the org’s internal tracking. Additionally, we will keep a record of Stripe webhook events (at least success/failure messages) in a payments_log or similar table for support troubleshooting. For example, if a payout to a yard fails or a webhook isn’t processed, we have a log of it. We will also log any failures from the fitment API (e.g. if the API is down or returns an error for a query) so we can detect issues with vehicle lookup. Since support resources are minimal, these logs will help developers or support staff quickly pinpoint where a process failed (whether it’s a Stripe transfer or a data fetch).
Deployment & Environment: The app will be deployed on Vercel for hosting the Next.js front-end and API routes. Vercel provides automatic scaling, CDN edge caching, and zero-downtime deploys which are beneficial for a SaaS platform. We will configure environment variables for sensitive keys: for example, SUPABASE_URL and SUPABASE_ANON_KEY (used on client-side for public data queries), a SUPABASE_SERVICE_KEY (used server-side for privileged DB access such as in API routes or incremental static regeneration, kept only server-side), STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, etc. On Vercel, we’ll use separate environments for development, staging (if needed), and production, each with their own env vars and connected to the appropriate Supabase project and Stripe account. Supabase itself hosts the Postgres database and auth; it can scale by choosing higher tiers if our user base grows. We should enable Supabase’s automated backups and have a plan for larger storage if many images are uploaded (Supabase storage can scale or we enforce some limits per image). The Supabase project will have the necessary config: enable Row Level Security on all data tables, define storage buckets, and possibly some edge functions (though likely not needed if we handle logic in Next.js API routes).
SEO & Analytics: The platform will generate SEO-friendly pages for each tire listing and possibly for each vehicle search. We will have clean URLs and proper <title> and <meta description> tags that incorporate keywords like tire sizes, vehicle names, and the yard’s location/name to attract search engine traffic. For example, a page title might be “Used 205/55R16 Tires – [Yard Name] Inventory” and description “Find quality used 205/55R16 tires at [Yard Name]. Fits Honda Civic, Toyota Corolla, and more. Live inventory with prices and online checkout.” We will also create a sitemap for each yard’s public pages. Basic web analytics (page views, etc.) can be included via a tool or simple tracking to help yards see traffic (this can be a later addition).
Future Enhancements (Out of Scope for Initial Release):
After delivering the core features above, several enhancements can be considered in later phases:
Marketplace Aggregation: Eventually, we may introduce a centralized marketplace page where a customer can search across all participating yards’ inventories in one go. This would involve an aggregated search index and possibly the ability to add tires from different sellers into one cart (which complicates checkout because multiple Stripe Connect destinations would be needed). This is deferred due to complexity; initially, customers will search one yard at a time.
Shipping Integration: In the initial version, how tires reach the buyer is handled offline (the yard contacts the buyer for pickup or arranges shipping manually). In future, we could integrate shipping carriers (UPS/FedEx) to calculate shipping costs at checkout and allow the yard to purchase/print shipping labels through the platform. This would require weight/dimension info for each tire and integration with shipping APIs, so it’s postponed for now.
Tax Calculation: We assume prices listed by yards either include any tax or tax is handled offline. A future feature might integrate a sales tax API (like TaxJar or Stripe Tax) to automatically calculate taxes based on buyer location for online sales, if needed.
Advanced Inventory Import/Sync: Beyond CSV uploads, we could add integration to pull inventory from a yard’s internal system or other platforms. Also, a more user-friendly CSV mapping tool could be added to handle different file formats.
Multi-User Roles: As mentioned, supporting multiple user logins per yard with role-based access (e.g. an “Inventory Manager” who can manage listings but not billing, etc.) can be added later. The groundwork with an organization_users table and RLS is laid, but the UI for inviting users and managing roles can come in a later update once a yard requests multi-user support.
Custom Domains or Deep Branding: In a later phase, yards might map their own domain (e.g. myyardtires.com) to their storefront. Vercel makes this possible with domain aliases, but it involves additional setup per customer. For now, they will use the default platform domain or a subdomain. Similarly, deeper branding (custom themes, colors) for each storefront could be added in the future.
Mobile App: Given the mobile-first design, a progressive web app (PWA) approach might suffice, but if needed, a dedicated mobile app (using React Native or Expo with Supabase) could be built later for yards to manage inventory by scanning barcodes, etc., or for customers.
Application Pages & User Flows
Below is a breakdown of the main pages and flows in the application, covering public-facing pages, authentication, the admin interface, and Stripe-related pages:
Public Storefront Pages (per Yard)
Landing/Search Page: This is the homepage for a yard’s storefront. It prominently displays the yard’s name/logo and a search interface. The search interface allows two modes: “Search by Tire Size” (free text input or dropdowns for width/ratio/rim) and “Search by Vehicle” (dropdowns for Year, Make, Model, Trim). On mobile, this may be a simple set of dropdowns or a guided flow (first select year, then make, etc.). The page may also show some featured inventory or categories (like a list of common sizes or tire brands the yard has) for browsing. If the yard has no inventory yet, it will show a friendly message like “Inventory coming soon.” Searching will navigate to the Search Results page (or dynamically update results below the form via client-side fetch).
Search Results Page: After the user enters a query (size or vehicle), the results page lists matching tires from that yard. If by size, it finds exact matches first. If none (or as an addition), it lists similar size alternatives (with a note like “No exact 205/55R16 in stock. Showing similar sizes that fit 16″ rims within 3% diameter tolerance”). If by vehicle, it uses the fitment sizes from cache/API to find matching inventory. Results are displayed as a list or grid of tire listings, each showing key info: size, brand/model, condition (if provided), tread depth (e.g. 5/32”), price, and an image thumbnail. If the yard allows checkout, each listing card has an “Add to Cart” button (or “View Details” which then allows adding). If checkout is disabled for this yard, the button might say “View Details” or “Contact to purchase” leading to details without a direct cart. We ensure results load quickly; if a vehicle query yields multiple OE tire sizes (some cars have front/back different or optional sizes), we combine results for all relevant sizes.
Tire Detail Page: Clicking a listing goes to that tire’s detail page. URL might include the tire ID or a slug. This page shows all info about the tire: multiple images (with carousel or thumbnails), detailed description (the admin can enter notes like brand, model, any patches or repairs, etc.), the size, load/speed ratings if provided, the quantity available, and the price. It can also list vehicle fitment compatibility – e.g. “Fits: 2012–2015 Honda Civic, 2010–2017 Toyota Corolla, ...” based on what the fitment API provides for that size (this can be cached as well, essentially reverse lookup of which popular vehicles use this size). This helps SEO and user confidence that the tire fits their car. If the yard has online sales on, the page has a quantity selector and Add to Cart button. If not, it might say “Call [Phone] to Purchase” or a contact form.
Cart Page: (Only for yards with checkout) The cart is typically a slide-out or a dedicated page listing the items the customer has selected, with quantities and subtotals. Customers can adjust quantities or remove items here. We also calculate any additional fees: if the yard passes the platform fee to the customer, we will show a “Service Fee 2%” line and calculate that amount here. If the yard charges sales tax or shipping (not in MVP scope), those would appear as well. At the bottom is the total amount. The cart page will have a Checkout button to proceed. If the yard’s plan is fee-based and they have not connected Stripe, the checkout button might be disabled with a message “Checkout is temporarily unavailable” (since they can’t receive payments yet) – however, we expect yards will complete Stripe onboarding before enabling their checkout publicly.
Checkout Page: When the user clicks Checkout, we either bring them directly to Stripe Checkout (skip an intermediate page), or we show a minimal checkout page to collect any info Stripe doesn’t (depending on Stripe Checkout configuration). Stripe Checkout can be configured to collect shipping address and email. We will likely rely on Stripe to handle collecting the payment and shipping details to simplify compliance. So the “Checkout” button will trigger a Next.js API route call to create a Stripe Checkout Session. That API route will compute the final line items and create the session with proper Connect parameters. Then on the client we use stripe.redirectToCheckout(sessionId). We will set the Stripe success_url to point to an Order Confirmation page on our site, and cancel_url back to the Cart.
Order Confirmation Page: This page (/order/success for example) is shown after a successful Stripe Checkout redirect. It thanks the customer for the purchase and displays an order summary (we query our database by session ID or use Stripe’s session data to identify the order). It will list order number, items, and what to expect (e.g. “The seller will contact you to arrange pickup/shipping.”). If desired, we could provide the yard’s contact info here too (“If you have questions, call the yard at ...”). There will also be a unique URL for the order that the customer could bookmark or receive via email (sending confirmation emails is a possible extension, but not required in spec). Similarly, a Cancellation page handles the case the user aborts payment – it might just return them to the cart with an alert “Payment was not completed.”
Authentication Pages
Sign Up Page (Register): The registration page allows a new yard admin to create an account and an organization in one step. Required fields: name, email, password for the user account, plus the yard/organization name. We might also ask for a phone number and location (city/state) of the yard as part of onboarding, or that can be filled in later in Settings. We use Supabase Auth for user management; the simplest is email/password sign-up. (Supabase can handle email verification emails if we enable it). The sign-up form, upon success, creates a new Supabase auth user and also inserts a record in our organizations (yards) table linking that user as the owner. We’ll have server-side logic or a trigger to do this (Supabase can run a trigger on new user signup to create a profile and org entry). After sign-up, if on a trial, we mark the trial expiration date in the org record. Then we redirect the new user into the Onboarding flow (a few setup steps as below).
Login Page: A standard email/password login form (or Magic Link if enabled, but likely just password). Users enter credentials, Supabase returns a session JWT which we use for authenticated routes. We’ll also support “Forgot Password” which triggers Supabase’s password reset email. Since only yard admins/employees log in (customers do not need accounts to buy tires), we do not have a separate customer login flow in MVP. So all Auth pages are geared toward yards.
Onboarding Steps (Post-Signup): After a new yard registers, we present a guided onboarding inside the admin interface:
Welcome & Branding: Confirm the yard’s name, allow them to upload a logo and maybe choose a URL slug (if we let them customize their storefront URL). The slug must be unique; we’ll either pre-generate one from the name or let them pick (with validation). This slug is used in the public URLs. If subdomains are implemented later, this would also become their subdomain.
Choose Plan: Still in trial, but we ask them to choose which plan they intend to use (they can change later, but this affects what we prompt next). If they choose the $99/mo listing plan, we might capture credit card info now or at least remind them that after 30 days they’ll be charged – we could integrate Stripe Checkout for a “$0 trial” that transitions to subscription, or simply mark their choice and defer actual payment until trial end. If they choose the $0 + 2% plan, we immediately prompt them to connect their Stripe account (because without it, they can’t actually receive any sales). It’s possible some yards want to just use the free trial of listing without deciding; we should allow skipping this in trial with a default (e.g. default to transaction plan but not live until they connect Stripe, or default to listing plan trial). We’ll clarify in UI that they won’t be charged during trial.
Stripe Connect (if needed): If they chose the transaction-fee plan, we present the Stripe Connect onboarding link. This could be a button “Set up payouts with Stripe” which opens the hosted form. We’ll supply Stripe with a redirect back to a dedicated Stripe Connect Return page in our app that handles the OAuth callback. That return page will check if the connection was successful and update the org’s stripe_account_id and status. If they skip this, we warn that they’ll need to connect before selling online.
Add First Tire Listing: Encourage the new user to add at least one tire to see how it works. They can choose “Add Manually” or “Import CSV”. The manual form page opens where they input tire details (with live validation for size format, etc.) and upload a photo. We’ll have defaults for some fields to speed entry (e.g. dropdowns for common brands, etc., possibly pre-seeded). If they choose CSV import, we show instructions about format and allow file upload; after upload, we parse and show a preview of entries to confirm before inserting. Once confirmed, those items appear in their inventory.
All Set: Finally, a confirmation that their storefront is ready, with a link to “View Your Public Page” and instructions that they can continue adding inventory and customize settings. We might also highlight where to find the Settings and Inventory pages in the admin UI. This completes onboarding.
Admin Dashboard & Internal Pages
Once logged in (or after onboarding steps), the user has access to the admin interface. This is typically a React app served via Next.js pages under an authenticated context (e.g. any route under /admin requires login). We can enforce this by checking the user session JWT on the server side (Next.js middleware or server components) and redirect to login if not present. Main admin sections (as introduced in features):
Dashboard Home: A quick overview page. It might show some metrics (e.g. number of active listings, total tires in stock, maybe last 7 days orders or page views if we track that). It can have shortcut buttons like “Add New Tire” and “View Inventory” and “View Orders”. This page is mostly for future expansion (analytics, tips, etc.). Initially it can be minimal or even skip directly to Inventory page.
Inventory List Page: Shows a table of the yard’s tire listings. Columns could include a small photo, size, brand/model, price, quantity, and maybe a publish status. There will be an “Add New” button here. Each row can be clicked to edit or have action buttons (Edit, Delete). We might allow quick inline edits for price or quantity. For better organization, we might allow filtering by size (search box) or by attributes (e.g. show only winter tires, etc., if such fields exist). The yard user uses this page to manage their catalog. Deleting a listing will remove it (or archive it if we want to keep data – could be immediate delete for now). We will implement a confirmation to avoid accidental deletes.
Add/Edit Tire Page: A form for tire details. Fields:
Size: There are a few ways to capture size. Possibly we have three separate inputs (Width, Aspect Ratio, Rim Diameter) or one string. To reduce errors, a combined format input with validation might be best (user types “205/55R16” and we parse it). Storing them separately in the DB is useful for querying, but the UI can be one field. We ensure the format is correct and maybe auto-fill the “R” if they omit.
Brand: Text or dropdown if we have a list of manufacturers (Michelin, Goodyear, etc.). Could be free text initially.
Model: Free text (e.g. “Eagle Sport”).
Category/Type: Possibly a dropdown for All-season, Winter, Performance, etc., if relevant. Could be added later.
Condition: Perhaps “Used” or “New” or a text field. Maybe a numeric field for Tread Depth (in 32nds of an inch) which is important for used tires; the yard can measure and input (e.g. 6/32”). We can have a field for that and possibly a field for the legal minimum indicator (if they want to note which are near end of life).
Quantity: Number of tires available in this listing.
Price: Price per tire (in USD; multi-currency not considered now). Possibly also a field if they charge for all in one, but likely per tire.
Photos: Upload one or multiple images. One should be marked as the main image. The UI for upload can allow selecting multiple files; we compress them client-side and then upload to Supabase Storage. We might use Supabase’s provided UI or SDK to upload, and store the returned URL or path in an array in the tire record.
Description/Notes: A text area for any notes (e.g. “Set of 4, one has a patch, price is per tire” etc.).
Possibly fields like SKU/Inventory Code if the yard has internal reference (not needed for public, but for their own tracking).
After filling the form, user hits Save. It creates a new tire record associated with their org_id. Edit page is similar, with fields pre-filled; editing updates the record. Validation will ensure no required fields are missing (size, price, etc.). Also, if they put a price extremely high or a quantity unrealistic, we might warn but not strictly limit.
Bulk CSV Import: Likely implemented as a modal or separate page accessible from Inventory. The user uploads a CSV file. We parse it (possibly on client using PapaParse or on server) and show how many entries will be created. We’ll require specific column headers (documented in the UI, e.g. Size, Brand, Model, Condition, TreadDepth, Quantity, Price, Notes). If any row has errors (e.g. missing size or price), we highlight it for the user to fix in CSV or we allow editing in an import preview table. On confirmation, we batch insert the new records into tires table. We should also upload images if the CSV includes image URLs or filenames (this is advanced; initial CSV might not handle images, user can edit later to add images manually). After import, the new listings appear in inventory.
Orders Page (Admin): Only visible if the yard has online sales (i.e. a Stripe account linked and using that plan). It shows a list of orders, newest first. Each entry shows at least order ID, date, total amount, and status. Possibly buyer name for identification. Clicking an order opens the Order Detail view.
Order Detail (Admin): Displays all info for a given order: the buyer’s name, contact (email, phone if collected), and address (if shipping info was collected). It lists the tires purchased (with size, quantity, price each, subtotal). It shows payment status (Paid, or Refunded, etc.). If we allow marking fulfillment, there could be a toggle or dropdown where the yard can mark an order as “Shipped” or “Ready for pickup” etc., and maybe enter a tracking number. These can send an email to the buyer if we integrate email (future enhancement). If a refund came in via Stripe webhook, the interface would indicate refunded amount. For now, the admin can’t directly initiate refunds from our app (they’d use their Stripe dashboard), but in future we could allow that through Stripe’s API. The focus now is providing information to the yard about what was sold.
Settings Page: Split into subsections:
Profile: Yard’s public information. Fields like Organization Name (which might be locked if used in URLs, or editable with caution), address, phone number, business hours (if we display that), logo upload (with preview and ability to change). Possibly also a textarea for “About us” or a blurb shown on their landing page.
Plan & Billing: Shows current plan (Listing plan or Transaction plan). If in trial, shows days left and a button to “Enter Payment Info” or “Subscribe” if they chose listing plan. For listing plan users, if they haven’t entered a card yet, a button triggers a Stripe Checkout for the subscription or a hosted Customer Portal link to update payment. We may use Stripe’s Customer Portal for managing billing info – the Settings page can have a “Manage Subscription” link that opens the Stripe portal (which allows updating card, canceling, etc.). For transaction plan users, this section shows that they will be charged 2% per transaction instead of a monthly fee, and possibly allows switching to the monthly plan if they change their mind (which would then require entering payment info). We will implement logic to handle plan switching: e.g. if a yard on transaction plan switches to subscription, we create a subscription in Stripe and perhaps require them to disconnect their Stripe Connect if they don’t want to sell online (or they could remain connected – being on subscription doesn’t forbid using checkout technically, but our pricing model assumed they wouldn’t use it; this edge case can be prevented by UI). If a yard on subscription switches to transaction plan, we’d cancel their Stripe subscription at period end and enable the 2% fee on their account.
Stripe Connect: (Only for transaction-fee plan or if the yard enabled checkout.) This section shows the status of their Stripe Connect account. If not connected: a prominent Connect with Stripe button. If connected: show “Connected as [Business Name] (Acct: acct_123xyz)”. Possibly show whether the account is fully verified or needs attention (Stripe provides an requirements.currently_due field – for simplicity, we might not surface it now, but support can see it via Stripe dashboard). We should also provide a link to refresh their Stripe account details – Stripe Express allows providing a dashboard link or on-demand onboarding update link. We can include a “Update Stripe Account Info” which generates an Account Link for updating, in case their payout info changes.
User Management: (If implemented) Lists current team members and invite feature. Initially, with single-user, this might not appear. In future, an admin can invite others by email, assign a role (Admin or Editor), and the invite sends an email via Supabase or our own system with a signup link to join that org. RLS policies already ensure only members can see the data, and roles can be enforced in the policy (e.g. only Admin can delete tires, etc.). For now, we assume the person who created the yard is the sole user and is an Admin by default.
Audit Log: The settings or a separate page can show an audit table. Columns: Date/Time, User, Action, Details. Actions include things like “Created listing 205/55R16 at $50 (Qty 4)”, “Edited listing 205/55R16 – changed price from $50 to $45”, “Order #1001 marked as Shipped”, “Connected Stripe account”, etc. This is mostly read-only. We might limit it to admin users of the org.
Support/Admin (Platform Level) Tools: This spec focuses on the product for the yards and their customers. However, as the platform operator, we should have some minimal tools for support and maintenance. This could be an internal “super-admin” panel (not accessible to yards) to manage the platform: view all organizations, their plans, trials, Stripe status; view logs of Stripe webhooks globally; impersonate an org if needed to help troubleshoot. Given the small scope, this can be as simple as directly querying the database or using Supabase Studio. We note this for completeness but it’s not part of the public deliverable to yards. Logging of Stripe and fitment API calls (success/failure) will be kept either in the database or in application logs as mentioned, to aid troubleshooting without a full dedicated support interface.
Data Model & Database Schema
We will use Supabase (Postgres) for storing all persistent data. Below are the main tables and their schemas, along with notes on relationships and row-level security policies:
organizations (yards) – Represents each tenant (salvage yard or tire seller).
Fields: id (UUID or bigserial primary key), name (text, yard name), slug (text, unique, for URL/subdomain), address (json or text fields for address, optional), phone (text), logo_url (text for storage path of logo in Supabase Storage),
plan_type (enum: “subscription” or “transaction”), trial_ends_at (timestamp), stripe_customer_id (text, for subscription billing), stripe_subscription_id (text, if on subscription plan), stripe_account_id (text, if they have a Connect account), stripe_connect_status (text or json, e.g. store some info from Stripe like charges_enabled),
created_at (timestamp), updated_at (timestamp).
Notes:
Plan logic: if plan_type = 'subscription', then stripe_subscription_id is used to track their active Stripe subscription (with status managed via webhooks). If plan_type = 'transaction', then stripe_account_id must be present for them to receive payouts; otherwise, their checkout cannot be active.
The trial period can be indicated either by trial_ends_at or by checking if no subscription and created less than 30 days ago. We’ll use an explicit field for clarity.
RLS: Generally, regular yard users should not SELECT all organizations (they should only see their own org info). We can allow each user to select their org row (filter by membership). Or simpler, we might not even query this table on client side beyond their org. A policy could be: org_id = any(orgs user belongs to) for select/update.
Public should not access this table directly at all, as it contains internal info.
users / profiles – Supabase auth.users table holds basic user accounts (id, email, etc.). We will create a parallel profile table to store user metadata and to link users to organizations. Alternatively, an organization_members join table for many-to-many. Likely we do:
profiles: id (UUID, primary key, matches auth.users ID), name (text, person’s name), email (text, could mirror auth email for convenience), org_id (UUID, references organizations.id), role (text, e.g. 'admin'), created_at.
This implies one user = one org (which is okay for now). If we wanted future multi-org support, we’d instead have organization_users: user_id, org_id, role and allow multiple. But for MVP, simplifying with one-to-one mapping via a field in profile is fine. The first user who signs up for an org is admin. If later we allow invites, we’d add the join table for additional users and set the profile.org_id to one primary org (or deprecate that field).
RLS: For profiles, an individual should see only their profile (using auth.uid() = id) – not particularly needed to expose others anyway. For organization_users, if implemented, policy would ensure you can only see your org’s members if you’re part of it.
tires – The core inventory table for tire listings.
Fields: id (UUID or serial PK), org_id (UUID references organizations), size (text, e.g. "205/55R16" format), plus possibly separate numeric fields: width (int), aspect_ratio (int), rim_diameter (int) for indexing and calculations. brand (text), model (text), category (text, e.g. All-Terrain, Winter, etc., optional), condition (text, e.g. "Used", "New"), tread_depth (numeric, e.g. 5.0 meaning 5/32" remaining, optional), quantity (int), price (numeric, e.g. in cents or as decimal), description (text),
images (json or text[] array of image file paths),
created_at, updated_at.
We may also store some precomputed metrics: diameter_inches (numeric) – calculated overall diameter of the tire. This can be computed as: diameter = rim_diameter + 2 * (width * (aspect_ratio/100) / 25.4). Storing it can make the “within 3%” query easier (we then compare this field). If not stored, we compute on the fly.
Indexes: We will index org_id (since we always filter by org) and possibly a composite index on (org_id, size) for exact searches. If we want to search by width or diameter ranges, indexes on those fields help.
RLS Policies: Only users from the same org can select or modify their tires. e.g. using (org_id = auth.jwt.claims.org_id) if we encode it, or via membership lookup. For anonymous (public) access, we do not want to allow selecting all tires without filter. We might not provide a direct supabase read to anon; instead, our server will query with the specific org filter using service key. Another approach: create a Postgres function get_tires(org_slug, filters) that can be called by anon (no auth) and internally does SELECT ... FROM tires WHERE org_id = (SELECT id from organizations where slug=org_slug) AND ... and returns only those rows. We can mark that function as security invoker or definer appropriately to bypass RLS safely for that controlled scenario. This way, public site could call a Supabase Edge Function or RPC to get tire listings for a given org slug. Regardless of method, the public can only retrieve tires of a specific yard at a time, not everything.
orders – Table for customer orders (sales).
Fields: id (UUID or serial PK – could also use Stripe’s payment intent ID or our own order number generator), org_id (references organizations, the seller), stripe_payment_intent_id (text, to tie back to Stripe if needed), stripe_checkout_session_id (text), status (text enum: e.g. 'paid', 'refund', 'disputed', 'cancelled'), subtotal (numeric), fee_amount (numeric, the platform fee for this order if any), total (numeric), currency (text, default "usd"), created_at, updated_at. Buyer info fields: customer_name (text), customer_email (text), customer_phone (text, if collected), shipping_address (json or text, if collected – could break into street, city, etc.). Also perhaps stripe_customer_id (text) if we create Stripe Customer records (Stripe Checkout can create one or we might not bother unless needed for future use).
Relationships: One order has many order_items (see next), so we normalize line items.
RLS: Only the yard’s users (org_id match) should select their orders. No one else, and certainly not public. Customers (buyers) are not authenticated users in our system, so they won’t have direct access to this; we rely on email for order confirmation rather than an account area.
order_items – Line items for orders.
Fields: id (PK), order_id (FK to orders), tire_id (FK to tires, optionally we might store a copy if tire was deleted), description (text – copy of the tire name/size at time of purchase, to avoid issues if original record changes), quantity (int), unit_price (numeric). Possibly tire_size, tire_brand fields redundant to description for easy filtering.
This allows orders with multiple different tire listings. (Our UI will support multi-item cart, so yes multiple line items possible if the buyer wants different tires).
RLS: Same as orders (join via order -> org). We might not query items independently much; always via an order join.
organization_members – (If multi-user support) each row links a user to an org with a role. Fields: org_id, user_id, role. For now, not used if we stick with profile.org_id approach.
audit_log – Records admin actions.
Fields: id, org_id, user_id, action (text short description), details (text longer or JSON with structured info), created_at.
We populate this via application code whenever a significant event occurs (or via Postgres triggers on certain tables for certain ops). E.g. after an INSERT on tires, a trigger could log “user X added tire Y (size)” to this table. Or simply our API route handlers will insert logs.
RLS: Only org members can see their org’s logs. Possibly we allow no edits/deletes to this table from client – just select.
stripe_events (optional) – Log of webhook events. Fields: id, type (e.g. 'checkout.session.completed'), data (JSON of payload), received_at. This can be a lot of data; we might choose not to store full payloads forever. Could be useful in debugging. This likely has no RLS (only platform admin would view, not yard users). So it could be in a separate schema or behind service-key only.
fitment_cache – Caches vehicle-to-tire results (and possibly tire-to-vehicle). We can have a table for vehicle queries:
Fields: id (PK), year, make, model, trim (all text fields), oe_tire_sizes (text[] or JSON of sizes), created_at (for cache age).
We might also cache the reverse: tire_size -> vehicles (e.g. store a few popular models that use that size for showing on tire detail pages). This could be another table or included in the above in a JSON. Alternatively, we don’t need to persist tire->vehicles; we can call the API for that or derive from the vehicle table. But caching vehicles for each size could be heavy. Likely focus on caching vehicle->sizes for search, which is needed more.
When a user searches by vehicle, the server will check this table: if entry exists for that exact Year/Make/Model/Trim, and is not too old (maybe update yearly if model year is new), then use the cached oe_tire_sizes. If not, call external API, get sizes, insert into this table, then proceed.
RLS: Since this is not sensitive per tenant (it’s global reference data), we could keep it open for read to any authenticated user or even anon. However, only our server really needs to query it. We can treat it as a public cache – but perhaps put it in a separate schema or restrict direct access. The Next.js server can query it with the service role as needed.
Row-Level Security & Policies:
All tables in the default public schema will have RLS turned on. Policies will be defined such that:
For tables like tires, orders, order_items, audit_log:
Select: org_id = auth.jwt.claims.org_id (for authenticated users). In SQL, this can be: USING ( org_id = current_setting('request.jwt.claims.org_id')::uuid ) if we put org_id in JWT. Or using a subquery on membership: USING ( auth.uid() IN (SELECT user_id FROM organization_members WHERE org_id = tires.org_id) ). We will likely set a custom claim on login for simpler policies. Supabase allows adding custom JWT claims via triggers or calling a function after auth. We can implement that during the sign-up flow (for example, after user signs up, do auth.jwt.set_claim('org_id', new_org_id)).
Insert/Update/Delete: similar check ensuring the user’s org_id matches the row’s org_id for writing. We might also allow inserts on certain tables only if user is admin role (we can embed role info in JWT or do a join check). Initially, with single user=admin, we allow them full access to their data. If multi-role later, we refine policies.
For organizations table:
We might allow each user to select their own org row. If each profile has org_id, we can allow USING ( id = auth.jwt.claims.org_id ). This way a user can retrieve their org’s info (like name, etc.) but not others. Insert is done only by our backend (on sign-up). Update could be allowed for org admins (policy check user is admin of that org).
For profiles:
USING ( id = auth.uid() ) so users can select/update only their profile. Or if we allow org admins to see all profiles in their org (for user management), then we need a join policy: allow select of profiles where profiles.org_id = auth.jwt.claims.org_id. This would let you see colleagues. That’s fine if implemented.
Public access: No table is fully open to anon by default, except perhaps a RPC function for searching inventory. We will create a supabase stored procedure or REST endpoint (edge function) that intentionally allows reading certain data for public users. Supabase Edge Functions (serverless functions in TS/JS) could be used as an alternative to Next.js API for fitment API calls or other backend tasks. However, since we have Next.js server, we might centralize there.
To summarize, each tenant’s data is isolated by org_id and RLS ensures strict separation – even if a malicious client tried to query another org’s ID, the database would filter it out. This provides defense-in-depth beyond just application logic.
Stripe Connect Integration Details
Using Stripe Connect is crucial for the transaction-fee plan to route payments to the yard sellers. Here’s how we implement it:
Connect Account Type: We will use Express accounts for an optimal balance of easy onboarding and platform control. Express accounts require the platform to handle the onboarding UI via Stripe’s hosted flow and pay a $2/month fee per active account (which is acceptable if yards are paying us via fees or subscription). We considered Standard accounts (no monthly fee, user manages their own Stripe dashboard) but that complicates user experience (redirecting to Stripe’s site). Express keeps users more tied to our platform’s experience. (If we wanted full control, we’d use Custom accounts, but that requires much more compliance work on our side and handling payouts directly – not needed here).
Onboarding Flow: When a yard admin opts into online sales (likely during onboarding or later in settings), they click “Connect with Stripe”. Our backend uses Stripe’s API to create a Connect Account (Express) for them, if not already created. We capture their email and business_type (individual vs company – likely individual/sole proprietor by default). We then create an Account Link (Stripe API) with account, refresh_url, and return_url. The return URL is a page on our app (e.g. /stripe/oauth-return) that we’ll set up to handle when the user completes the Stripe form. The user is redirected to Stripe’s onboarding, where they provide details (bank account, SSN/EIN, etc. as required by Stripe for KYC). After completion, Stripe redirects back to our return URL with account and refresh_state. We then fetch the account status via Stripe API to confirm it’s completed. We save the stripe_account_id (acct_xxx) in the organization record and mark something like payouts_enabled = true/false based on Stripe’s response. If onboarding was incomplete, we can use the refresh_url to let them try again.
Charging Customers: When a customer checks out, we use Direct Charges (also known as destination charges in this context) where the charge is made on the platform account but immediately attributed to the connected account with a transfer. Specifically, in Stripe’s terms, we set transfer_data[destination] to the connected account ID, and an application_fee_amount for our 2% (if applicable). This way, Stripe will automatically split the payment: the net minus fee goes to the connected account’s balance, and our fee goes to our platform balance. This also means the platform is the “Merchant of Record” for the transaction in the sense that Stripe shows the charge on our account but it’s on behalf of the seller – with Express, this is the recommended approach. Funds in the connected account are then paid out on their schedule (daily/weekly). We do not have to micromanage payouts, Stripe does that (Express accounts get daily automatic payouts by default, I believe, or whatever the account holder sets).
Passing Fees vs Absorbing: Implementation-wise, if a yard is absorbing the fee, we compute application_fee_amount = 2% of (item prices subtotal). If passing fee, we compute the fee similarly but also add that amount to the Checkout Session line items as an extra fee line (so the customer pays it). Example: Tire total $100, fee 2% = $2. Absorbing: we create checkout session for $100 total, and set app_fee=200 cents. Passing: we create checkout session for $102 total (two line items: tires $100, “Service Fee” $2), and set app_fee=200 cents. In either case, Stripe will transfer $fee to us and the remainder to seller. The difference is who ultimately paid the $2 – the customer or coming out of the seller’s share. The UI on checkout/cart will reflect accordingly.
Stripe Subscription for SaaS Billing: For yards on the $99 plan, we create a Product and Price in Stripe (e.g. product “UsedTire SaaS Subscription”, price $99 monthly). We can either handle trial by creating subscription with trial_period_days=30 or by only creating the subscription at end of trial. A simpler approach: when user enters billing info, create the subscription with trial, so they are not charged immediately but automatically in 30 days. Stripe will handle charging the card and will send webhook events (invoice.payment_succeeded, etc.). We’ll listen for those to know when a trial converts or a payment fails. If a payment fails, we might downgrade the account to trial mode and alert the user to update payment. If they cancel, we switch them to the transaction plan or freeze their account if they don’t want that either. The subscription is tied to the platform’s own Stripe account (not connect, since it’s our revenue). So stripe_customer_id in org table links to a customer in our Stripe account representing the yard, and stripe_subscription_id for their active sub.
Webhooks & Events: We will register a webhook endpoint (via Stripe’s dashboard or API) for relevant events:
For Connect transactions: checkout.session.completed (to know an order was paid), payment_intent.succeeded (possibly redundant with checkout session), charge.refunded, charge.dispute.created (and charge.dispute.closed). Also transfer.failed in case a payout to seller fails (though Stripe also emails them). We’ll focus on core ones: session completed triggers order creation in DB; refund/dispute events trigger order status updates and possibly email notifications to yard.
For Subscription billing: invoice.payment_succeeded, invoice.payment_failed, customer.subscription.deleted (cancellation), etc. On payment failure, we might notify the yard and give a grace period; on final failure or cancellation, we could automatically switch them to the other plan (with transaction fees) so at least their account isn’t gone, but this is a business decision. Initially, we might lock their admin access until resolved (with a banner “please update billing to continue”).
Each webhook event will be handled in a Next.js API Route (/api/stripe-webhook) configured to verify Stripe signature. We parse the event type and perform the necessary DB updates. We log events to stripe_events table for record.
Stripe Testing: We’ll use Stripe’s test mode for development, with test API keys. We will have to test Connect flows (Stripe provides test bank accounts, etc.) and subscription. Ensure to swap to live keys for production. Also, ensure we handle idempotency for webhooks (Stripe may send the same event again). Use Stripe’s provided IDs to guard against duplicate processing (e.g. store last processed event ID or design our order creation to be idempotent by checking if order with that session ID exists).
Fees and Transfers Accounting: Stripe automatically deducts their processing fee from either the seller or platform depending on charge type. With our approach (destination charge), Stripe will deduct their fee from the platform’s portion by default. For example, customer pays $102, of which platform application_fee is $2 – Stripe might take ~3% (~$3) from the $102 total from our Stripe balance (since charge is on our account). However, Stripe’s docs indicate that with application_fee on destination charges, the Stripe fee is taken from the platform’s balance after transferring funds. We need to ensure the economics: If platform is absorbing Stripe fees or not. Actually, Stripe will charge fees on the total amount but since most of amount went to connected account, they adjust the transfer so that connected account ends up with their amount minus their portion of fee. For simplicity, we don’t need to manually do anything – just be aware that out of our 2% fee, some will go to Stripe fee if we are covering it. We have factored 2% as our revenue before Stripe’s cut, which is fine for now. (We could increase fee slightly if needed to cover Stripe’s ~2.9%, but that’s business detail beyond scope – possibly the $99 plan covers that overhead).
Payouts to Sellers: With Express accounts, sellers can log into a lightweight Stripe dashboard to see their payouts. We as platform can also query balances via API if needed to show in our UI (maybe future). But out-of-box, we might not show payout info on our site; yards will rely on Stripe emails or logging into their Express dashboard (Stripe usually emails them when payout sent). In Settings, we could put a link “View Payouts” that links to Stripe Express dashboard for that account.
Testing for Fees Toggle: We should test both scenarios (absorb vs pass) thoroughly to ensure the math and Stripe outcomes are correct. This is just noted for QA.
Image Upload and Storage Strategy
To reiterate, we will use Supabase Storage for storing tire images (and yard logos). We’ll create at least two buckets: one for public/yard-logos and one for public/tire-images. We mark them as public or use signed URLs. Likely, public read is acceptable for these assets to simplify usage (so that images can be directly loaded via URL). Upload will be restricted by auth via policies: e.g. only logged-in yard users can upload to their folder. Supabase Storage has its own RLS mechanism – we can configure that by defining a storage policy: e.g. bucket = 'tire-images' and auth.uid() != null for inserts, and maybe check the file path contains their org_id to ensure one org can’t overwrite another’s file (we could include org_id or slug in the key path). Another approach is to not worry because the worst a malicious user could do is read another’s images which isn’t severe. However, we should prevent deletion of others’ images. We can generate object paths that include the org slug or ID for namespacing. E.g. on uploading “tire123.jpg” for org 456, we actually put it at tire-images/456/tire123.jpg. Then a storage rule can allow: auth.uid() that belongs to org 456 can manage files in folder 456/*, etc. On upload, our front-end will handle compression as described. Once the file is prepared (as a Blob or File object under say 200 KB ideally), we use the Supabase client or a direct HTTP PUT to storage (Supabase provides APIs). Alternatively, we might simply use an <input type="file"> and then call a Next.js API route to stream it to Supabase using the service key (less efficient). Supabase JS client is fine here as the user is authed. After uploading, we get the public URL or path, and we store that in the tire record’s images field. For display, we can either use that public URL in an <img> tag or through Next/Image for auto-sizing. If any server-side image processing is needed (like creating thumbnails), we could integrate an Edge Function triggered on storage (Supabase can trigger a function when a new file is stored) that generates a smaller thumbnail and stores it. This could be a later optimization. Given we do client-side resizing, it might already be small enough to use as thumbnail. We must also consider image format: we will likely convert to JPEG to maximize compatibility (except if the original is PNG and it’s needed, but tires photos can be JPEG). We can also consider WebP for modern browsers, but to keep it simple, compress to JPEG at ~80% quality which greatly reduces file size. As one source notes, using Canvas to compress images in-browser is an effective way to reduce size without significant quality loss. We’ll implement that based on the code from PQINA or similar guides. Finally, ensure the UX for uploading is smooth (progress indicator, etc., can be minimal initially). We should also guard against extremely large files (e.g. someone tries to upload a 10MB photo – our compression should handle it, but also maybe warn if after compression it’s still huge).
External Fitment Data Handling
For vehicle-to-tire fitment queries, as noted, we plan to use an external API such as the Wheel-Size.com API or a similar Tire fitment API. Wheel-Size.com provides a comprehensive database of vehicles and their stock tire sizes. We will register for an API key (their free tier allows some requests per day, which might suffice initially, else we may need a paid plan as usage grows). Another option is the tire.vdim.app API which similarly provides endpoints to search by vehicle or by tire size. The integration approach:
We create a server-side helper (could be an API route in Next or a serverless function) that given (year, make, model, trim) returns a list of tire sizes. If the request is not in cache, the helper makes an HTTP request to the external API endpoint (e.g. GET to api.wheel-size.com/v2/search/by_model/?year=YYYY&make=MAKE&model=MODEL&trim=TRIM&user_key=APIKEY). The API responds with one or more tire size specifications (including optional sizes). We parse that to extract the size codes, e.g. "205/55R16". We then store it in our fitment_cache table.
Subsequent requests for the same vehicle can hit the cache. The cache could be keyed by an exact match on (year, make, model, trim). We should normalize make and model names (case, spacing) to match what API expects or what we store.
We might also prefetch some data: e.g. if a user selects Year and Make in the UI, we might call an endpoint to get available Models for that make/year (the API likely has endpoints for list of models by year/make). To make the dropdowns dynamic without too much lag, we have options: either fetch a full list of makes/years from the API on load (which can be cached or even stored permanently since vehicle data doesn’t change often, especially historical) or embed a static list of popular makes. A compromise: use the API on demand with caching. For example, when year is selected, call API for makes available that year (or we might have a static list of makes – probably easier to have a static list of major makes, since that doesn’t vary by year typically except maybe brands come/go). Then when a make is selected, call API for models for that year+make (this we cache per year+make). Then trim list for model (cache per model). These are more minor details – if needed to implement fully dynamic dropdowns, we can incorporate those endpoints. Wheel-Size API does have endpoints for list of models, etc.
For the MVP, we could simplify by providing a fixed set of popular vehicle data (like a JSON of common Year/Make/Model) to avoid too many API calls, but that could become outdated. It might be acceptable to require the user to type the model instead of dropdown – but better UX is dropdown. Given time, caching these progressively is fine.
Once we get tire sizes from the API, often there can be multiple sizes (especially optional wheel packages). We will consider all of them in search.
Similar Size Suggestions: For size search, we will implement logic to find tires with same rim diameter and overall diameter within ±3%. As discussed, storing a diameter_inches in each tire listing can help. The query would be something like: find tires where rim_diameter = X and ABS(diameter_inches - target_diameter) / target_diameter <= 0.03. We can do that in SQL or fetch all same-rim tires and filter in JS. Because each yard’s inventory isn’t massive, it’s fine to do it in memory or with a calculated field. This yields candidates which we then sort by how close they are to target (closest first). We’ll label them as “similar”. This calculation is well-grounded in tire replacement guidelines (the 3% rule).
We will communicate on the UI that these are alternatives and may affect speedometer etc., leaving final decision to user (maybe a small disclaimer).
Caching for similar sizes: not needed, it’s an on-the-fly calc on inventory.
Performance: The fitment API calls will be server-side, so our API key is not exposed. We must be mindful of not doing too many calls. The caching strategy will mitigate repetitive calls (e.g. if many users search Civic 2010, we call API only once then reuse). We might also batch results: e.g. if an API returns front and rear tire different sizes (some sports cars), we cache both.
We will monitor API failures: e.g. if the API is down or returns error (maybe if car not found), we handle gracefully: show “Unable to fetch fitment data, please search by tire size.” and log the error to our logs for review. This ties to the “minimal support tools” note: logging these events.
In the future, if the external API cost becomes an issue, we could consider importing a dataset of tire sizes for vehicles into our own database to reduce dependency. But initially, using the API with limits is fine.
Deployment and Environment Configuration
Deployment will be done to Vercel for the front-end application. Key deployment considerations:
Environment Variables: We will store secrets in Vercel’s environment settings. These include:
NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY for the Supabase project (public config for client usage – the anon key has very limited rights due to RLS).
SUPABASE_SERVICE_ROLE_KEY for server-side use (this key bypasses RLS, used in API routes or ISR for secure operations like generating initial data or performing admin tasks like stock decrement in a transaction). We must keep this secret (only use it on server side code).
STRIPE_SECRET_KEY (our Stripe API key for the platform account), STRIPE_WEBHOOK_SECRET (to validate incoming webhooks). Possibly separate webhook secrets for Connect vs regular events if needed (Stripe can sign events either way, often one secret if they’re all through one endpoint).
STRIPE_PUBLISHABLE_KEY (to use Stripe.js on client for any direct card elements; in our case we mainly redirect to Stripe Checkout so this might not be heavily used, but we might include it for completeness).
STRIPE_PRICE_ID for the $99 subscription product (or we fetch it from Stripe API by product name in code, but easier to configure it).
FITMENT_API_KEY for the vehicle data API (Wheel-Size or alternative).
NEXT_PUBLIC_BASE_URL to know our domain (used for redirect URLs for Stripe, etc. – although we can also use Vercel’s environment host).
Perhaps environment flags like NODE_ENV, etc., handled by Next/Vercel automatically.
We will have separate values for development (possibly using a .env.local that points to a dev Supabase and Stripe test keys) and production (set in Vercel prod env).
Supabase Project Setup: We need to create the schema as described in the Supabase project. We can use Supabase’s SQL migration or the web UI to create tables, and define RLS policies. We will enable email/password auth in Supabase (and possibly allow OAuth providers in the future, but not needed initially). We will also configure storage buckets via the Supabase dashboard (naming them and setting public access or policies). Supabase’s URL and anon key will be provided to the front-end. We have to ensure RLS is enabled on all tables (Supabase by default does on new tables created through their UI). We'll write the policy SQL or use their UI for RLS. Example policy for tires table (in SQL terms, for reference):
-- Allow org members to manage their tires create policy "Org members can CRUD tires" on public.tires for all using ( auth.role() = 'authenticated' and org_id = (select org_id from public.profiles where id = auth.uid()) ) with check ( org_id = (select org_id from public.profiles where id = auth.uid()) );
 This uses the profile mapping to get org. Alternatively, if we added org_id to JWT:
create policy "Org members read tires" on public.tires for select using ( org_id = current_setting('request.jwt.claims.org_id')::uuid );
 etc. We might use the latter for simplicity if we include org_id claim (which requires a trigger to refresh JWT after profile creation or using Supabase’s JS library to set additional claims). This is a technical nuance, but the outcome is each query acts as if WHERE tires.org_id = <user's org>. We will also add an insert policy for orders that allows our backend to insert new orders (maybe using service role or a policy that allows if the correct org). Actually for inserting orders, it’s our server (with service key) doing it, so we could bypass RLS. But we might also allow if the inserting user’s org_id matches (the user in context would be the yard? Actually orders insertion is triggered by webhook (server), so better to do with service role to avoid any complexity). Additionally, for the function or RPC that fetches public tires by slug, we might mark it as SECURITY DEFINER (runs with owner permissions) so it can select from tires ignoring RLS but filtering by slug internally. Then we allow anon to execute that function. This way, the public site can call e.g. rpc/get_inventory_by_slug?slug=yard-name without exposing everything. If not comfortable with that, we simply do it in Next server with service key (which is straightforward too). The choice may lean to just doing SSR via service key to deliver pages.
Scaling & Performance on Vercel: Vercel will auto-scale our Next.js application as needed, so if traffic spikes (mostly read operations to view listings), it will spin up more serverless instances. Our app should be stateless except Supabase calls, which is fine. Supabase itself might be the bottleneck if under heavy load, but our usage (simple queries, not extremely high volume) is likely fine on a standard plan. If needed, we can upgrade the Supabase tier (more CPU/RAM for Postgres).
Also, we should use caching where possible: Next.js can use Incremental Static Regeneration (ISR) for pages that don’t change often. For example, a tire detail page could be statically generated and revalidated every hour or when an update occurs (we can revalidate on inventory changes via a webhook or API call). That would make serving detail pages extremely fast globally. Search pages are more dynamic due to query parameters, so those we handle with SSR or client fetch. We can also cache common search results in memory for a short time to reduce DB load (not built-in but could use something like a LRU in the server if we had persistent instances – but with serverless, better to rely on DB caching and indices). Supabase (Postgres) will cache frequently accessed data in memory as well.
Monitoring & Error Tracking: We may integrate a service like Sentry for error tracking on client and server, but if not, we will at least output errors to console (which Vercel captures) and use Supabase logs. Supabase’s pgBouncer and database monitoring can be checked if performance issues arise (like slow queries due to RLS overhead – then we add indexes as recommended). Logging Stripe events and fitment errors as noted helps in identifying issues quickly.
CI/CD: Every commit to main branch can auto-deploy via Vercel. We should protect production secrets and possibly use separate Supabase projects for dev and prod. We’ll run tests (if any automated) locally; for now, manual testing of flows will be key before going live.
In summary, deploying on Vercel with a managed database (Supabase) provides a robust, scalable setup out of the box. We primarily need to ensure configuration is correct (env vars, domain, webhook URLs pointing correctly). We will configure the Stripe webhook to the Vercel deployed URL (e.g. https://app.example.com/api/stripe-webhook). For local dev, we can use the Stripe CLI to forward webhooks.This specification covers all major aspects of the application: from UI/UX pages, data schema, business logic, to integration with external services. It is designed to be comprehensive enough for a developer (or AI agent) to implement the system. The focus has been on fulfilling the core requirements (multi-tenant inventory, fitment search, optional checkout with dual pricing model) while outlining where future enhancements can be layered in. By adhering to this plan, we will build a fast, user-friendly platform that significantly modernizes how salvage yards sell used tires, while ensuring scalability and maintainability through a solid technical architecture. Sources:
Multi-tenant data isolation with Postgres RLS
Subdomain routing for multi-tenant SaaS (Next.js middleware and wildcard domains)
Vehicle tire fitment API (Wheel-Size database & tire size by vehicle lookup)
Tire replacement 3% diameter rule for size compatibility
Client-side image compression using Canvas API (reduce upload size)
Stripe Connect usage with application fees (destination charges with transfer and fee amount)
Multi-tenant Tire E-commerce Platform – Feature Overview
The system should be designed mobile-first and support multiple independent “yards” (stores) on one platform, with each yard having a branded storefront. In a mobile-first approach, layouts and interactions are designed for smartphones first, then scaled up for larger screens. This ensures optimal user experience for the majority of customers who shop on mobile. Each yard’s store can either be delivered via a white-label embed on the yard’s website or via its own subdomain (e.g. yardname.platform.com). Both are viable: using yard-specific subdomains (multi-tenant SaaS model) lets each yard have a unique URL and branding, while an embedded storefront (white-label snippet/iframe) keeps customers on the yard’s own site. In practice, many platforms treat a small number of related subdomains as one site for SEO, so either approach can work. Design-wise, use responsive CSS and frameworks so the UI is mobile-optimized first (e.g. simple navigation, large touch targets, fast loading on phones).
Tire Search (Size & Vehicle Fitment)
Implement a robust fitment search so customers can find tires by vehicle or tire specifications. Typically this means a Year/Make/Model (YMM) lookup and tire-size filters. We will host our own fitment database (e.g. in Supabase’s PostgreSQL) rather than rely on a third-party API. A fitment tool allows users to input a vehicle’s details and quickly discover compatible tires. For example, azFitment provides a plug-and-play lookup where selecting year, make, model, (and engine) “allows your customers to discover the exact components they need”. In our case, store vehicle fitment data (e.g. via ACES or other catalogs) in Supabase. Supabase is a managed backend platform based on Postgres that offers instant REST APIs and real-time updates. We can define tables for makes/models and tire-fitment mappings. On the frontend, allow filtering by tire size (width, profile, rim) or by vehicle. This ensures customers quickly find tires that fit their car.
Database Backend: Use Supabase’s Postgres database to store fitment data and tire records. Each record can link a tire SKU to one or more vehicle fits.
Search UI: Provide fields (Year, Make, Model, Engine, tire width/diameter, etc.) to filter tires. Matching entries query the Supabase DB. This emulates tools like azFitment’s lookup.
Performance: Index the vehicle fields for fast lookup. Supabase’s real-time APIs can return results quickly on selection changes.
Inventory Listings & Bulk Quantity Management
Each yard should be able to list tires for sale, specifying stock quantity. The UI should allow adding one listing at a time or batch uploading many listings (bulk mode). It is common in e-commerce to support CSV-based bulk product uploads. For example, platforms like Shopify or Amazon let sellers download a CSV template, fill in product details (including quantity), and upload it. We should implement a similar feature: allow yards to download or fill a spreadsheet of tire info (size, brand, description, price, available units) and import it to create/update multiple listings at once.
Individual Listing: For each tire listing, include fields for stock quantity (number of sets or tires available) and other details (size, condition, etc.). If selling tires in bundles (e.g. pairs or sets of 4), either treat a “set” as one unit or allow a flag to indicate “price is per set” (see Pricing below).
Bulk Upload: Provide a CSV import tool. As noted in e-commerce best practices, most platforms use CSV templates for bulk management. This lets yards rapidly add hundreds of tire SKUs.
Inventory Controls: When items sell, decrement the stock count automatically. If needed, support batch editing of stock levels (e.g. adjust quantities for many SKUs). Clearly display remaining stock for each listing so yards know when to restock.
Order Processing & Notifications
When a customer places an order, it should immediately appear in the yard’s admin interface, and an email notification should be sent out. The workflow: customer orders → order record created in database → admin dashboard updates → transactional email triggered. For emailing, integrate with an email service like Brevo (formerly Sendinblue). Brevo is designed for ecommerce emails (order confirmations, shipping updates, etc.). We can use Brevo’s API or SMTP to send:
Order Confirmation (to customer): Summarize purchase.
Admin Notification: Alert the yard owner/staff with order details.
Workflow: Upon order creation in our system, call Brevo’s API to send the emails.
On the admin side, display all order info (customer, items, total, payment status) in an Orders Dashboard. Each new order should be visible with status updates. This ensures yards can process orders quickly and keep records. (Brevo provides ecommerce-specific templates for “post-purchase” emails, which we can leverage for consistency.)
Pricing Plans & Payment Integration
Support multiple pricing tiers for the service itself. For example, a Listing-Only Plan ($99/month) can give yards access to the system without additional transaction fees (the platform takes no commission). Customers on this plan can still process credit-card payments (we integrate a payment gateway for sales), but the platform simply does not deduct a percentage fee from those sales. In contrast, a standard plan might charge a commission per transaction. Regardless of plan, integrate a credit-card processor (Stripe, PayPal, etc.) so yards can accept online payments for orders. The notes mention using “the cc system” (credit card) and no platform fee on the listing-only plan. This means: connect each yard’s store to Stripe (possibly via a platform account) so customers can pay by card. For listing-only plan users, skip any commission logic in our code (they pay only the monthly fee).
Subscription Billing: Implement our own billing for the $99 subscription (using Stripe or a similar billing API).
Payment Gateway: Use Stripe (or similar) to accept payments. On purchase, process payment in our system and mark order paid.
Commission Logic: Check user’s plan. If “Listing-Only”, then do not deduct platform fee; otherwise, optionally apply a commission or processing fee.
Orders Management & Refunds
Each yard needs an Orders Management page to review all transactions. This page should list every sale (order ID, date, items, total, customer info) and provide summary metrics (e.g. total revenue, total orders). It should also include controls to process refunds or cancellations. Best practice (as seen in multi-vendor platforms) is to allow filtering and actionable orders. For example, Spree Commerce’s marketplace admin dashboard lets vendors “view orders by vendor, status or tag” and cancel or refund items.
Order List: Show all orders for that yard, sortable/filterable by date, status (pending, paid, shipped, etc.), and with search.
Totals: Display running totals (daily/weekly/monthly sales) at top.
Refunds/Cancellations: For each order or line item, include a “Cancel/Refund” action. When triggered, reverse the payment in the processor (if applicable) and mark the order refunded. As in Spree: “Cancel, refund, or return items with notifications”.
Notifications: When an order is refunded or canceled, optionally send an email notification to the customer and note it in the admin UI.
Reporting: Optionally allow export of order data (CSV of transactions) for bookkeeping.
In-Person Checkout (POS)
Support a point-of-sale mode for in-person sales. This means staff should be able to ring up items (tire sets or services) on a tablet or desktop when customers pay on-site. Requirements:
Payment Methods: Accept cash or card. For cards, integrate with a card reader or use a payment gateway as above. For cash, simply record the payment and mark the order paid.
Price Overrides: Often in person, staff need to apply discounts or negotiate price. Implement an override/discount feature at checkout, enabled via a setting. For example, like Shopify POS allows “custom line-item discounts or price overrides” if the staff has permission. We can mimic this: in the POS flow, allow the user to change the price of an item before finalizing the sale (if “allow price edit” is enabled for their account).
UI: A simple checkout screen listing items being sold (with quantity), subtotal, tax, and payment input. A setting toggle (“Allow price overrides”) can be set per yard or per user role.
Receipts: Print or email receipts as needed.
Staff using POS should be limited by role: only managers/admins get the override ability, if policy requires (see User Roles below).
User Accounts & Roles
Implement a full User Management system. Each yard will have one or more user accounts (e.g. owner, staff). Key points:
Roles: Define at least two roles: Admin (yard owner or manager) and Sales/User (regular staff). Admins have full permissions: they can manage inventory, orders, users, and settings. Sales role can create/edit listings and take orders but might lack some privileges (depending on policy).
Role-based Access: As CloudFuze describes, SaaS permission management typically includes “account provisioning, role-based access assignment, [and] permission updates”. Use this approach: assign roles on user creation. The system’s UI and API should check permissions before actions (e.g. only Admin can refund orders or change tax settings).
Authentication: Standard sign-up/login with email/password. Possibly integrate with OAuth if needed.
User List: Admin view to invite or remove users for the yard, assign roles, reset passwords.
Activity: Track user actions (audit logs) if needed for security.
This ensures that each yard’s team can be managed and that sensitive functions are restricted.
Tax Configuration
Include built-in sales tax calculation. Let each yard configure one or more tax rates (for example, state and local tax). Provide a settings page where a yard admin can set their default sales tax percentage (and indicate if prices are tax-inclusive or tax-exclusive). Key considerations:
Rate Entry: Simply allow the yard to enter their local sales tax (e.g. 7.5%). For multi-jurisdiction, you might allow multiple rates by region, but to start a single rate is fine.
Destination vs. Origin: By default, most e-commerce states are destination-based, meaning tax depends on the customer’s location. If our customers’ shipping addresses are collected, we could calculate accordingly. (The Numeral guide notes that origin-based is simpler (tax on seller’s location), whereas destination-based “means you’ll need to calculate rates according to each customer’s location”.) We might start with origin-based (charge one rate on all sales) for simplicity, or integrate a tax API for destination tax rates later.
Include Tax Setting: Provide an option “Include tax in prices” vs “Add tax on top”. This lets users either enter prices that already include tax or have the system add tax at checkout.
Calculations: In checkout, calculate tax as subtotal × tax rate (if not included) or verify inclusive pricing if marked. Store tax amount in the order.
Display: Show tax amount on invoices and admin dashboards.
Onboarding & Site Integration
After signup, guide yards on integrating the storefront into their website. Provide a simple onboarding wizard or documentation. For example:
Code Snippet: Give them a ready-made JavaScript or HTML snippet (iframe widget) that they can paste into their own site. This snippet would display the yard’s store UI on their page. As stor.ai’s white-label solution advertises: “they are on your website/url, … with your brand”. Our snippet achieves that same effect.
Subdomain Setup: If using subdomains, instructions should be given for DNS CNAME or A-record pointing to our platform (or we manage it automatically). Document how to configure a custom domain or subdomain.
Demo/Preview: In the dashboard home or onboarding flow, show a preview of their public store and how to link to it.
Contact/Support: Provide a quick tutorial or support link on how to customize the embedded store (e.g. colors, logo).
Onboarding is crucial for first-time users: make it clear how to “show this on their website” (e.g., “copy this snippet into your site’s HTML” or “point your subdomain to our platform”).
Dashboard & Analytics
The home dashboard (after login) should show key analytics and recommendations from day one. At minimum include:
Sales Metrics: Total orders, revenue (today/this week/this month), number of customers, etc. Graphs of sales over time help identify trends.
Popular Products: List best-selling tire SKUs or categories, so yards know what’s moving.
Inventory Alerts: Highlight tires that are low in stock or out-of-stock. Advanced tools use predictive analytics to suggest restocking. For example, Shopify apps like “Bee Low Stock Alert” automatically warn merchants when inventory hits critical levels and even “calculate the ideal reorder quantities based on sales trends”. We should implement at least a simple low-stock alert (e.g. highlight items below a threshold) and possibly use sales velocity to suggest which tires to reorder.
Suggested Actions: Based on sales data, suggest which tire sizes or types are in demand. For example: “Customers have been searching for tire size X often; consider adding stock of that size.” This can help yards know what to add to inventory.
Exports/Reports: Allow downloading of reports (CSV) for more analysis. Tools like Report Toaster provide advanced inventory/sales reports, but our dashboard should at least have basic reporting.
By surfacing this data early, yards get insight into their business. In particular, showing “what tires need to be added to inventory” can be based on sales trends or low-stock signals, helping them prioritize restocking.
Product (Tire) Add/Edit Page
On the page where yards add or edit a tire listing, build in auto-save and collaboration safety. Since notes mention multiple users could be editing (one uploading images, another adding price), it’s prudent to prevent data loss:
Auto-save Drafts: As the user fills in fields (especially multi-step forms), periodically save a draft in the database. A good pattern is to auto-save after the user stops typing for a brief period. For example, detect inactivity (no input events) for ~2 seconds and then send an auto-save to the server. This ensures changes are not lost if the browser is closed unexpectedly.
Concurrent Edits: If two users open the same listing, the last save could overwrite the other’s changes. A simple approach: when loading the form, lock it (or notify “Another user is editing”). For more advanced handling, you could implement real-time locking via WebSockets, but even a naive “auto-save” as above helps preserve input if one user finalizes.
Feedback: Show a small “Draft saved” indicator after each auto-save.
Manual Save: Still provide an explicit “Save” button to finalize publishing the listing.
This approach (autosave on inactivity) is reliable and common in modern apps. It minimizes disruption while protecting edits.
Pricing Configuration
Each tire listing needs a price. Since tires are often sold in multiples (pairs or sets), allow flexible pricing:
Price per Unit: Default to price per tire. The yard enters a price and it applies to each tire.
Bundle Pricing (Optional): Some yards may want to sell in fixed sets (e.g. by the pair or set of 4). Offer an option (e.g. a checkbox or toggle) like “price is for X tires” or “sell as set of [2/4]”. This way, if they enter $300 for a set of 4, each tire is effectively $75 but customers buy 4 at once. Alternatively, allow them to input a “set price” separately from the unit price.
Currency: Per spec, use USD only (no multi-currency now). Display prices clearly with currency symbol.
Decimal Precision: Allow cents (two decimal places) for accuracy. Many e-commerce sites use charm pricing ($19.99), but that is optional.
No external citation needed; this is business logic. Just ensure the UI clearly indicates what unit the price refers to, to avoid confusion.
Image Upload & Storage
Implement an image upload/storage system for tire pictures:
Storage: Use a cloud storage service (e.g. Supabase Storage, AWS S3) for uploaded images. Store images with scalable buckets/CDNs for fast delivery. Limit file types (JPEG/PNG) and sizes for performance.
Multiple Images: Allow uploading multiple images per listing (front, side, tread, etc.).
Deletion Policy: Automate cleanup of images. When a tire listing is sold out or deleted, immediately delete its images from storage. This ensures we don’t accumulate unused files. (For example, in WooCommerce you’d remove gallery images when deleting a product; here we can do the same programmatically after status change.) This keeps storage cost down and avoids orphaned media.
Auto-Resize: On upload, optionally generate thumbnail and optimized versions for web to improve load times.
By handling images this way (cloud storage + cleanup), the app remains efficient and tidy. Sources: As noted, this approach parallels e-commerce best practices (e.g., removing images when products are deleted) and using services like Supabase for storage (see “Storage” feature on the Supabase platform page).




